#!/usr/bin/python

# This program processes an address trace generated by the Valgrind lackey tool
# to create a reduced trace according to the Fastslim-Demand algorithm 
# described in "FastSlim: prefetch-safe trace reduction for I/O cache 
# simulation" by Wei Jin, Xiaobai Sun, and Jeffrey S. Chase in ACM Transactions
# on  Modeling and Computer Simulation, Vol. 11, No. 2 (April 2001), 
# pages 125-160. http://doi.acm.org/10.1145/384169.384170

import fileinput
import sys
import argparse
from operator import attrgetter


class TraceItem(object):

    def __init__(self, reftype, pg, tstamp):
        self.reftype = reftype
	self.pg = pg
	self.tstamp = tstamp
	self.marked = False

    def __eq__(self, other):
        return self.pg == other.pg

    def __repr__(self):
        return self.reftype + " " + format(self.pg*4096,'x')

    def __hash__(self):
	return hash(self.pg)


ts = 0               # "timestamp" (entry number in original trace)
tracebuffer = set()  # The set of entries in the buffer
toprint = []         # The list of entries waiting to be printed in order

# Emit in timestamp order may have to hold onto items until the trace buffer
# is emptied, because there may be marked items in the trace buffer with 
# earlier timestamps that have to appear in the output first. 
# So, we put entries into a list as they are first seen and then 
# emit_marked adds all marked items to the list. 
# The list is then sorted by timestamp and printed.
def emit_marked_in_ts_order():
	for ti in tracebuffer:
		if ti.marked:
			toprint.append(ti)
	toprint.sort(key=attrgetter('tstamp'))
	for ti in toprint:
		print ti
	tracebuffer.clear()
	del toprint[:]

# Parse command line arguments
parser = argparse.ArgumentParser(description="Reduce address trace from valgrind using fastslim-demand algorithm.")
parser.add_argument('-k', '--keepcode', action='store_true', help="include code pages in compressed trace")
parser.add_argument('-b', '--buffersize', type=int, default=4, help="number of entries in trace buffer")
parser.add_argument('tracefile', nargs='?', default="-")
args = parser.parse_args()

# Process input trace
for line in fileinput.input(args.tracefile):
	if line[0] == '=':
		continue

	reftype = line[0:2].strip()
	if reftype == "I" and args.keepcode == False:
		continue

	addrstr = line.split(',')[0][3:].strip()
        try:
            addr = int(addrstr, 16)
        except ValueError:
            #print "This does not appear to be valgrind output, skipping: " + line
            continue

	pg = addr / 4096
	ti = TraceItem(reftype,pg,ts)

	if ti in tracebuffer:
		ti.marked = True
		ti.tstamp = ts
	else:
		if (len(tracebuffer) == args.buffersize):
			emit_marked_in_ts_order()
		toprint.append(ti)
		tracebuffer.add(ti)
	ts = ts + 1
